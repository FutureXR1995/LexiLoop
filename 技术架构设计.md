# LexiLoop 技术架构设计
## 系统架构与技术选型详解

---

## 🏛️ 整体架构图

```
                    ┌─────────────┐
                    │   用户端     │
                    │ (Web/Mobile) │
                    └──────┬──────┘
                           │
                    ┌──────▼──────┐
                    │   CDN/负载   │
                    │   均衡器     │
                    └──────┬──────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                 │                  │
┌───────▼────────┐ ┌──────▼──────┐ ┌────────▼────────┐
│   前端应用      │ │   API网关    │ │   静态资源      │
│   (Next.js)    │ │   (Express)  │ │   (Vercel)     │
└────────────────┘ └──────┬──────┘ └─────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                 │                  │
┌───────▼────────┐ ┌──────▼──────┐ ┌────────▼────────┐
│   业务服务      │ │   AI服务     │ │   缓存层        │
│   (Node.js)    │ │   (Python)   │ │   (Redis)      │
└────────┬───────┘ └──────┬──────┘ └─────────────────┘
         │                │
         └────────┬───────┘
                  │
        ┌─────────▼─────────┐
        │     数据层        │
        │  (PostgreSQL)     │
        └───────────────────┘
```

---

## 🖥️ 前端技术架构

### 技术栈选择
```javascript
// package.json 核心依赖
{
  "dependencies": {
    "next": "^14.0.0",           // React框架
    "react": "^18.0.0",
    "tailwindcss": "^3.0.0",     // CSS框架
    "framer-motion": "^10.0.0",  // 动画库
    "zustand": "^4.0.0",         // 状态管理
    "react-query": "^3.39.0",    // 数据获取
    "howler": "^2.2.0",          // 音频播放
    "lucide-react": "^0.263.0"   // 图标库
  }
}
```

### 目录结构
```
frontend/
├── 📁 components/
│   ├── 📁 ui/                  # 基础UI组件
│   │   ├── Button.tsx
│   │   ├── Input.tsx
│   │   └── Modal.tsx
│   ├── 📁 features/            # 功能组件
│   │   ├── 📁 auth/
│   │   ├── 📁 story/
│   │   ├── 📁 test/
│   │   └── 📁 progress/
│   └── 📁 layout/              # 布局组件
├── 📁 pages/                   # Next.js页面
│   ├── api/                    # API路由
│   ├── auth/                   # 认证页面
│   ├── learn/                  # 学习页面
│   └── dashboard/              # 用户面板
├── 📁 hooks/                   # 自定义Hooks
├── 📁 utils/                   # 工具函数
├── 📁 stores/                  # Zustand状态管理
└── 📁 styles/                  # 样式文件
```

### 核心组件设计
```typescript
// 故事阅读组件架构
interface StoryReaderProps {
  story: Story;
  vocabulary: Vocabulary[];
  onWordClick: (word: string) => void;
  onComplete: () => void;
}

// 测试组件架构
interface TestComponentProps {
  questions: Question[];
  onAnswer: (answer: Answer) => void;
  onComplete: (results: TestResult) => void;
}
```

---

## ⚙️ 后端技术架构

### 技术栈选择
```javascript
// package.json 核心依赖
{
  "dependencies": {
    "express": "^4.18.0",        // Web框架
    "typescript": "^5.0.0",      // 类型系统
    "prisma": "^5.0.0",          // ORM数据库
    "jsonwebtoken": "^9.0.0",    // JWT认证
    "bcryptjs": "^2.4.0",        // 密码加密
    "redis": "^4.6.0",           // 缓存
    "joi": "^17.9.0",            // 数据验证
    "winston": "^3.10.0"         // 日志记录
  }
}
```

### API设计规范
```typescript
// RESTful API 设计
interface APIEndpoints {
  // 用户认证
  'POST /api/auth/register': RegisterRequest;
  'POST /api/auth/login': LoginRequest;
  'POST /api/auth/refresh': RefreshTokenRequest;
  
  // 词汇管理
  'GET /api/vocabularies': GetVocabulariesRequest;
  'POST /api/vocabularies/select': SelectVocabulariesRequest;
  
  // 故事生成
  'POST /api/stories/generate': GenerateStoryRequest;
  'GET /api/stories/:id': GetStoryRequest;
  
  // 学习测试
  'POST /api/tests/submit': SubmitTestRequest;
  'GET /api/tests/results/:id': GetTestResultsRequest;
  
  // 用户进度
  'GET /api/progress': GetProgressRequest;
  'POST /api/progress/update': UpdateProgressRequest;
}
```

### 数据库设计
```sql
-- 用户表
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  username VARCHAR(100) NOT NULL,
  level VARCHAR(20) DEFAULT 'beginner',
  preferences JSONB DEFAULT '{}',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 词汇表
CREATE TABLE vocabularies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  word VARCHAR(100) NOT NULL,
  definition TEXT NOT NULL,
  pronunciation VARCHAR(200),
  difficulty_level INTEGER NOT NULL,
  category VARCHAR(50),
  frequency_rank INTEGER,
  created_at TIMESTAMP DEFAULT NOW()
);

-- 故事表
CREATE TABLE stories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  content TEXT NOT NULL,
  vocabulary_ids UUID[] NOT NULL,
  difficulty_level INTEGER NOT NULL,
  word_count INTEGER NOT NULL,
  audio_url VARCHAR(500),
  cache_key VARCHAR(255) UNIQUE,
  created_at TIMESTAMP DEFAULT NOW()
);

-- 学习记录表
CREATE TABLE learning_records (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id),
  story_id UUID NOT NULL REFERENCES stories(id),
  vocabulary_ids UUID[] NOT NULL,
  test_results JSONB NOT NULL,
  completion_time INTEGER NOT NULL,
  accuracy_rate DECIMAL(3,2) NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

-- 用户进度表
CREATE TABLE user_progress (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id),
  vocabulary_id UUID NOT NULL REFERENCES vocabularies(id),
  mastery_level INTEGER DEFAULT 0,
  correct_count INTEGER DEFAULT 0,
  incorrect_count INTEGER DEFAULT 0,
  last_reviewed TIMESTAMP,
  next_review TIMESTAMP,
  UNIQUE(user_id, vocabulary_id)
);
```

---

## 🤖 AI服务架构

### AI服务技术栈
```python
# requirements.txt
fastapi==0.104.0          # Web框架
openai==1.3.0             # OpenAI API
azure-cognitiveservices-speech==1.34.0  # Azure TTS
redis==5.0.0              # 缓存
pydantic==2.5.0           # 数据验证
sentence-transformers==2.2.2  # 文本相似度
nltk==3.8.0               # 自然语言处理
```

### 故事生成服务
```python
# story_generator.py
class StoryGenerator:
    def __init__(self):
        self.openai_client = OpenAI()
        self.cache = Redis()
        self.quality_validator = ContentValidator()
    
    async def generate_story(
        self, 
        vocabulary: List[str], 
        difficulty: int,
        story_type: str = "general"
    ) -> Story:
        # 1. 检查缓存
        cache_key = self._generate_cache_key(vocabulary, difficulty, story_type)
        cached_story = await self.cache.get(cache_key)
        
        if cached_story:
            return Story.parse_json(cached_story)
        
        # 2. 构建prompt
        prompt = self._build_story_prompt(vocabulary, difficulty, story_type)
        
        # 3. 调用GPT生成
        response = await self.openai_client.chat.completions.create(
            model="gpt-4o",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7,
            max_tokens=1000
        )
        
        story_content = response.choices[0].message.content
        
        # 4. 质量验证
        is_valid, quality_score = await self.quality_validator.validate(
            story_content, vocabulary
        )
        
        if not is_valid:
            # 重新生成或使用备选方案
            return await self._generate_fallback_story(vocabulary, difficulty)
        
        # 5. 生成音频
        audio_url = await self._generate_audio(story_content)
        
        # 6. 创建故事对象
        story = Story(
            content=story_content,
            vocabulary=vocabulary,
            difficulty=difficulty,
            audio_url=audio_url,
            quality_score=quality_score
        )
        
        # 7. 缓存结果
        await self.cache.setex(
            cache_key, 
            timedelta(hours=24), 
            story.json()
        )
        
        return story
```

### 内容质量验证
```python
# content_validator.py
class ContentValidator:
    def __init__(self):
        self.sentence_transformer = SentenceTransformer('all-MiniLM-L6-v2')
        
    async def validate(self, content: str, vocabulary: List[str]) -> Tuple[bool, float]:
        # 1. 词汇覆盖率检查
        vocab_coverage = self._check_vocabulary_coverage(content, vocabulary)
        
        # 2. 内容连贯性检查
        coherence_score = self._check_coherence(content)
        
        # 3. 可读性检查
        readability_score = self._check_readability(content)
        
        # 4. 语法正确性检查
        grammar_score = self._check_grammar(content)
        
        # 综合评分
        overall_score = (
            vocab_coverage * 0.3 +
            coherence_score * 0.3 +
            readability_score * 0.2 +
            grammar_score * 0.2
        )
        
        is_valid = overall_score >= 0.7
        
        return is_valid, overall_score
```

---

## 🚀 部署与运维架构

### 云服务选择
```yaml
# docker-compose.yml
version: '3.8'
services:
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    environment:
      - NEXT_PUBLIC_API_URL=${API_URL}
      
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      
  ai-service:
    build: ./ai-service
    ports:
      - "8001:8001"
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - AZURE_SPEECH_KEY=${AZURE_SPEECH_KEY}
      
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
      
  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=lexiloop
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
```

### 监控与告警
```typescript
// 性能监控指标
interface PerformanceMetrics {
  // 响应时间指标
  api_response_time: number;
  ai_generation_time: number;
  database_query_time: number;
  
  // 业务指标
  daily_active_users: number;
  story_generation_count: number;
  test_completion_rate: number;
  
  // 系统指标
  cpu_usage: number;
  memory_usage: number;
  disk_usage: number;
  error_rate: number;
}
```

### 成本控制策略
```typescript
// AI调用成本控制
class CostController {
  private readonly dailyBudget = 1000; // $1000/day
  private readonly hourlyLimit = 50;   // $50/hour
  
  async checkBudget(): Promise<boolean> {
    const todaySpend = await this.getTodaySpend();
    const hourlySpend = await this.getHourlySpend();
    
    return todaySpend < this.dailyBudget && 
           hourlySpend < this.hourlyLimit;
  }
  
  async optimizeGeneration(request: GenerationRequest): Promise<Strategy> {
    // 1. 检查缓存命中率
    const cacheHitRate = await this.getCacheHitRate();
    
    // 2. 根据用户等级调整质量
    const qualityLevel = this.getQualityLevel(request.userTier);
    
    // 3. 批量生成优化
    if (request.batchSize > 5) {
      return this.getBatchStrategy();
    }
    
    return this.getStandardStrategy();
  }
}
```

---

## 🔒 安全架构设计

### 认证与授权
```typescript
// JWT认证策略
interface AuthStrategy {
  accessToken: {
    expiry: '15m';
    payload: UserBasicInfo;
  };
  refreshToken: {
    expiry: '7d';
    storage: 'httpOnly cookie';
  };
  rateLimiting: {
    login: '5 attempts/hour';
    api: '1000 requests/hour';
    ai_generation: '100 requests/hour';
  };
}
```

### 数据安全
```sql
-- 数据加密与脱敏
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 敏感数据加密存储
ALTER TABLE users ADD COLUMN email_encrypted BYTEA;

-- 数据访问日志
CREATE TABLE access_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID,
  action VARCHAR(100) NOT NULL,
  resource VARCHAR(200) NOT NULL,
  ip_address INET NOT NULL,
  user_agent TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);
```

---

**这个技术架构确保LexiLoop能够稳定、安全、高效地为用户提供AI驱动的词汇学习服务，同时具备良好的可扩展性和可维护性。**